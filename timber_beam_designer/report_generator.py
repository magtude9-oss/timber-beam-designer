"""
Professional PDF report generator for timber beam design using fpdf2.
Mathcad-inspired style: formula-forward with expressions on the left,
evaluated results on the right, thin rule separators.
Variable names in muted grey, monospaced for calcs, sans-serif headings.
Subtle colour accents for section headers. B&W base overall.

Capacity equations per NZS AS 1720.1:2022 Section 3:
  Bending:  Md  = phi * k1 * k4 * k6 * k9 * k12 * f'b * Z      [Eq. 3.2(2)]
  Shear:    Vd  = phi * k1 * k4 * k6 * f's * As                  [Eq. 3.2(14)]
  Bearing:  Nd,p = phi * k1 * k4 * k6 * k7 * f'p * Ap            [Eq. 3.2(16)]
"""

import base64
import tempfile
import os
from datetime import date
from fpdf import FPDF

from .logo_b64 import LOGO_B64
from .material_data import K4_DRY, K6_DEFAULT
from .beam_analysis import SIMPLY_SUPPORTED, OVERHANGING


# ── Colour constants ────────────────────────────────────────────────
CLR_HEADING = (40, 60, 90)       # muted blue-grey for section headings
CLR_VAR = (100, 100, 120)        # muted grey-blue for variable names
CLR_BLACK = (0, 0, 0)
CLR_PASS = (0, 100, 0)
CLR_FAIL = (200, 0, 0)
CLR_RULE = (180, 180, 180)       # light grey rules


def _get_logo_path():
    """Decode base64 logo to a temp file and return the path."""
    data = base64.b64decode(LOGO_B64)
    tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".png")
    tmp.write(data)
    tmp.close()
    return tmp.name


class TimberBeamReport(FPDF):
    """Mathcad-inspired engineering calculation report."""

    # Font family names — set dynamically in __init__ based on OS
    FONT_SANS = "LeelawadeeUI"
    FONT_MONO = "LeelawadeeUI"

    def __init__(self, project_info: dict, logo_path: str):
        super().__init__()
        self.project_info = project_info
        self.logo_path = logo_path

        # Try Windows Leelawadee UI first; fall back to built-in Helvetica
        # (Streamlit Cloud runs Linux where Windows fonts aren't available)
        font_dir = r"C:\Windows\Fonts"
        leelawui = os.path.join(font_dir, "LeelawUI.ttf")
        if os.path.exists(leelawui):
            self.add_font(self.FONT_SANS, "",  leelawui)
            self.add_font(self.FONT_SANS, "B", os.path.join(font_dir, "LeelaUIb.ttf"))
            self.add_font(self.FONT_SANS, "I", leelawui)
        else:
            # Use fpdf2 built-in fonts (no file needed)
            TimberBeamReport.FONT_SANS = "Helvetica"
            TimberBeamReport.FONT_MONO = "Courier"

    def header(self):
        if self.logo_path and os.path.exists(self.logo_path):
            self.image(self.logo_path, x=10, y=6, w=22)

        self.set_font(self.FONT_SANS, "B", 13)
        self.set_text_color(*CLR_HEADING)
        self.cell(0, 7, "Timber Beam Design Calculation", align="C",
                  new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(*CLR_BLACK)

        self.set_font(self.FONT_SANS, "", 7)
        info = self.project_info
        right_lines = [
            f"Project: {info.get('project_name', '')}",
            f"No: {info.get('project_number', '')}",
            f"Beam: {info.get('beam_id', '')}",
            f"Designer: {info.get('designer', '')}",
            f"Date: {info.get('date', '')}",
        ]
        y_start = 7
        for i, line in enumerate(right_lines):
            self.set_xy(135, y_start + i * 3.5)
            self.cell(65, 3.5, line, align="R")

        self.set_y(27)
        self.set_draw_color(*CLR_HEADING)
        self.set_line_width(0.6)
        self.line(10, 27, 200, 27)
        self.set_draw_color(*CLR_BLACK)
        self.ln(4)

    def footer(self):
        self.set_y(-14)
        self.set_draw_color(*CLR_RULE)
        self.set_line_width(0.3)
        self.line(10, self.get_y(), 200, self.get_y())
        self.ln(1)
        self.set_font(self.FONT_SANS, "I", 6.5)
        self.set_text_color(100, 100, 100)
        self.cell(90, 3.5, "Calculated by Magnitude Engineering", align="L")
        self.cell(0, 3.5, f"Page {self.page_no()}/{{nb}}", align="R",
                  new_x="LMARGIN", new_y="NEXT")
        self.set_font(self.FONT_SANS, "I", 5.5)
        self.cell(0, 3,
                  "This document is generated by automated calculation "
                  "-- verify inputs before use.",
                  align="C")
        self.set_text_color(*CLR_BLACK)

    # ── Formatting helpers ──────────────────────────────────────────

    def _space_left(self) -> float:
        """Remaining vertical space before auto page break (mm)."""
        return self.h - self.b_margin - self.get_y()

    def section_heading(self, number, title: str):
        # Only force a new page when truly no room (heading + one line)
        if self._space_left() < 14:
            self.add_page()
        else:
            self.ln(2)
        self.set_font(self.FONT_SANS, "B", 9.5)
        self.set_text_color(*CLR_HEADING)
        self.cell(0, 5, f"{number}.  {title}",
                  new_x="LMARGIN", new_y="NEXT")
        self.set_draw_color(*CLR_HEADING)
        self.set_line_width(0.4)
        self.line(10, self.get_y(), 200, self.get_y())
        self.set_draw_color(*CLR_BLACK)
        self.set_text_color(*CLR_BLACK)
        self.ln(1.5)

    def sub_heading(self, text: str):
        # Only force a new page when truly no room
        if self._space_left() < 10:
            self.add_page()
        else:
            self.ln(0.5)
        self.set_font(self.FONT_SANS, "B", 8)
        self.set_text_color(*CLR_HEADING)
        self.cell(0, 4.5, text, new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(*CLR_BLACK)

    def info_line(self, label: str, value: str):
        self.set_font(self.FONT_SANS, "B", 7)
        self.set_text_color(*CLR_VAR)
        self.cell(55, 4, label, new_x="RIGHT", new_y="LAST")
        self.set_font(self.FONT_SANS, "", 7)
        self.set_text_color(*CLR_BLACK)
        self.cell(0, 4, value, new_x="LMARGIN", new_y="NEXT")

    def calc_expression(self, formula: str, result: str):
        y = self.get_y()
        self.set_font(self.FONT_MONO, "", 7)
        self.set_text_color(*CLR_VAR)
        self.cell(110, 4, f"  {formula}")
        self.set_draw_color(*CLR_RULE)
        self.set_line_width(0.15)
        self.line(122, y, 122, y + 4)
        self.set_font(self.FONT_MONO, "B", 7)
        self.set_text_color(*CLR_BLACK)
        self.set_xy(124, y)
        self.cell(0, 4, result, new_x="LMARGIN", new_y="NEXT")

    def calc_line(self, text: str):
        self.set_font(self.FONT_MONO, "", 7)
        self.set_text_color(*CLR_BLACK)
        self.cell(0, 4, f"  {text}", new_x="LMARGIN", new_y="NEXT")

    def calc_result_line(self, text: str, passed: bool = True):
        self.set_font(self.FONT_MONO, "B", 7)
        self.set_text_color(*(CLR_PASS if passed else CLR_FAIL))
        self.cell(0, 4, f"  {text}", new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(*CLR_BLACK)

    def thin_rule(self):
        self.set_draw_color(*CLR_RULE)
        self.set_line_width(0.15)
        self.line(12, self.get_y(), 198, self.get_y())
        self.set_draw_color(*CLR_BLACK)
        self.ln(1)


def _draw_triangle(pdf, cx, cy, size=3):
    """Draw a small upward-pointing triangle (pin support symbol)."""
    half = size / 2
    pdf.line(cx, cy, cx - half, cy + size)
    pdf.line(cx, cy, cx + half, cy + size)
    pdf.line(cx - half, cy + size, cx + half, cy + size)


def _draw_beam_diagram_ss(pdf, span_m, point_loads=None):
    """Draw a simply supported beam diagram showing w, L, supports, and point loads."""
    if pdf._space_left() < 32:
        pdf.add_page()

    x0 = 30       # left margin of diagram
    beam_w = 140   # beam drawing width in mm
    y_beam = pdf.get_y() + 6   # beam line y
    y_top = y_beam - 4          # top of UDL arrows

    pdf.set_draw_color(*CLR_HEADING)
    pdf.set_line_width(0.5)

    # Beam line
    pdf.line(x0, y_beam, x0 + beam_w, y_beam)

    # Supports: triangles at each end
    pdf.set_line_width(0.3)
    _draw_triangle(pdf, x0, y_beam, 3)
    _draw_triangle(pdf, x0 + beam_w, y_beam, 3)

    # Support labels
    pdf.set_font(pdf.FONT_SANS, "", 6)
    pdf.set_text_color(*CLR_VAR)
    pdf.set_xy(x0 - 3, y_beam + 4)
    pdf.cell(6, 3, "R1", align="C")
    pdf.set_xy(x0 + beam_w - 3, y_beam + 4)
    pdf.cell(6, 3, "R2", align="C")

    # UDL arrows (downward)
    n_arrows = 12
    pdf.set_line_width(0.2)
    pdf.set_draw_color(80, 80, 80)
    for i in range(n_arrows + 1):
        ax = x0 + i * beam_w / n_arrows
        pdf.line(ax, y_top, ax, y_beam)
    # Top line connecting arrows
    pdf.line(x0, y_top, x0 + beam_w, y_top)

    # UDL label
    pdf.set_font(pdf.FONT_SANS, "I", 7)
    pdf.set_text_color(*CLR_BLACK)
    pdf.set_xy(x0 + beam_w / 2 - 5, y_top - 5)
    pdf.cell(10, 4, "w*", align="C")

    # Span dimension line below
    y_dim = y_beam + 7
    pdf.set_draw_color(*CLR_VAR)
    pdf.set_line_width(0.15)
    pdf.line(x0, y_dim, x0 + beam_w, y_dim)
    # End ticks
    pdf.line(x0, y_dim - 1, x0, y_dim + 1)
    pdf.line(x0 + beam_w, y_dim - 1, x0 + beam_w, y_dim + 1)
    # Label
    pdf.set_font(pdf.FONT_SANS, "", 7)
    pdf.set_text_color(*CLR_BLACK)
    pdf.set_xy(x0 + beam_w / 2 - 10, y_dim)
    pdf.cell(20, 4, f"L = {span_m:.2f} m", align="C")

    # Point loads
    if point_loads:
        pdf.set_draw_color(200, 0, 0)
        pdf.set_line_width(0.4)
        for pl in point_loads:
            px = x0 + (pl.get("a_m", 0) / span_m) * beam_w
            pdf.line(px, y_top - 3, px, y_beam)
            # Arrow head
            pdf.line(px, y_beam, px - 1, y_beam - 2)
            pdf.line(px, y_beam, px + 1, y_beam - 2)
            pdf.set_font(pdf.FONT_SANS, "I", 6)
            pdf.set_text_color(200, 0, 0)
            pdf.set_xy(px - 3, y_top - 7)
            pdf.cell(6, 3, "P", align="C")

            # a dimension
            pdf.set_draw_color(*CLR_VAR)
            pdf.set_line_width(0.1)
            y_a = y_beam + 14
            pdf.line(x0, y_a, px, y_a)
            pdf.line(x0, y_a - 0.8, x0, y_a + 0.8)
            pdf.line(px, y_a - 0.8, px, y_a + 0.8)
            pdf.set_font(pdf.FONT_SANS, "", 6)
            pdf.set_text_color(*CLR_VAR)
            mid_a = (x0 + px) / 2
            pdf.set_xy(mid_a - 5, y_a)
            pdf.cell(10, 3, f"a={pl.get('a_m', 0):.2f}", align="C")

    pdf.set_draw_color(*CLR_BLACK)
    pdf.set_text_color(*CLR_BLACK)
    pdf.set_line_width(0.3)

    total_h = 16 if not point_loads else 20
    pdf.set_y(y_beam + total_h)


def _draw_beam_diagram_overhanging(pdf, ell_m, a_m, point_loads_back=None,
                                     point_loads_cant=None):
    """Draw an overhanging beam diagram showing back span, overhang,
    supports, UDL zones, and point loads."""
    total = ell_m + a_m
    if pdf._space_left() < 36:
        pdf.add_page()

    x0 = 25           # left margin
    beam_w = 150       # total beam width in mm
    y_beam = pdf.get_y() + 6
    y_top = y_beam - 4

    # Proportional widths
    ell_w = beam_w * ell_m / total  # back span width
    a_w = beam_w * a_m / total      # overhang width
    x_R1 = x0
    x_R2 = x0 + ell_w
    x_tip = x0 + beam_w

    pdf.set_draw_color(*CLR_HEADING)
    pdf.set_line_width(0.5)

    # Beam line
    pdf.line(x0, y_beam, x_tip, y_beam)

    # Supports
    pdf.set_line_width(0.3)
    _draw_triangle(pdf, x_R1, y_beam, 3)
    _draw_triangle(pdf, x_R2, y_beam, 3)

    # Support labels
    pdf.set_font(pdf.FONT_SANS, "", 6)
    pdf.set_text_color(*CLR_VAR)
    pdf.set_xy(x_R1 - 3, y_beam + 4)
    pdf.cell(6, 3, "R1", align="C")
    pdf.set_xy(x_R2 - 3, y_beam + 4)
    pdf.cell(6, 3, "R2", align="C")

    # Free end marker (small circle)
    pdf.set_draw_color(80, 80, 80)
    pdf.set_line_width(0.3)
    pdf.circle(x_tip - 0.8, y_beam - 0.8, 1.6)

    # UDL arrows on back span
    n_back = max(int(ell_w / 10), 4)
    pdf.set_line_width(0.2)
    pdf.set_draw_color(80, 80, 80)
    for i in range(n_back + 1):
        ax = x_R1 + i * ell_w / n_back
        pdf.line(ax, y_top, ax, y_beam)
    pdf.line(x_R1, y_top, x_R2, y_top)

    # UDL arrows on overhang
    n_cant = max(int(a_w / 10), 2)
    for i in range(n_cant + 1):
        ax = x_R2 + i * a_w / n_cant
        pdf.line(ax, y_top, ax, y_beam)
    pdf.line(x_R2, y_top, x_tip, y_top)

    # UDL labels
    pdf.set_font(pdf.FONT_SANS, "I", 6.5)
    pdf.set_text_color(*CLR_BLACK)
    pdf.set_xy(x_R1 + ell_w / 2 - 7, y_top - 5)
    pdf.cell(14, 4, "w*back", align="C")
    pdf.set_xy(x_R2 + a_w / 2 - 7, y_top - 5)
    pdf.cell(14, 4, "w*cant", align="C")

    # Vertical dashed line at R2 (separating zones)
    pdf.set_draw_color(*CLR_RULE)
    pdf.set_line_width(0.15)
    y_dash_top = y_top - 2
    y_dash_bot = y_beam + 3
    dash_len = 1.0
    y_d = y_dash_top
    while y_d < y_dash_bot:
        pdf.line(x_R2, y_d, x_R2, min(y_d + dash_len, y_dash_bot))
        y_d += dash_len * 2

    # Dimension lines below
    y_dim1 = y_beam + 7
    pdf.set_draw_color(*CLR_VAR)
    pdf.set_line_width(0.15)

    # Back span dimension (ell)
    pdf.line(x_R1, y_dim1, x_R2, y_dim1)
    pdf.line(x_R1, y_dim1 - 1, x_R1, y_dim1 + 1)
    pdf.line(x_R2, y_dim1 - 1, x_R2, y_dim1 + 1)
    pdf.set_font(pdf.FONT_SANS, "", 6.5)
    pdf.set_text_color(*CLR_BLACK)
    mid_ell = (x_R1 + x_R2) / 2
    pdf.set_xy(mid_ell - 12, y_dim1)
    pdf.cell(24, 3.5, f"ell = {ell_m:.2f} m", align="C")

    # Overhang dimension (a)
    pdf.line(x_R2, y_dim1, x_tip, y_dim1)
    pdf.line(x_tip, y_dim1 - 1, x_tip, y_dim1 + 1)
    mid_a = (x_R2 + x_tip) / 2
    pdf.set_xy(mid_a - 10, y_dim1)
    pdf.cell(20, 3.5, f"a = {a_m:.2f} m", align="C")

    # Total span dimension
    y_dim2 = y_dim1 + 4
    pdf.line(x_R1, y_dim2, x_tip, y_dim2)
    pdf.line(x_R1, y_dim2 - 1, x_R1, y_dim2 + 1)
    pdf.line(x_tip, y_dim2 - 1, x_tip, y_dim2 + 1)
    mid_total = (x_R1 + x_tip) / 2
    pdf.set_xy(mid_total - 12, y_dim2)
    pdf.cell(24, 3.5, f"L = {total:.2f} m", align="C")

    # Point loads on back span
    if point_loads_back:
        pdf.set_draw_color(200, 0, 0)
        pdf.set_line_width(0.4)
        for pl in point_loads_back:
            px = x_R1 + (pl.get("a_m", 0) / ell_m) * ell_w
            pdf.line(px, y_top - 3, px, y_beam)
            pdf.line(px, y_beam, px - 1, y_beam - 2)
            pdf.line(px, y_beam, px + 1, y_beam - 2)
            pdf.set_font(pdf.FONT_SANS, "I", 6)
            pdf.set_text_color(200, 0, 0)
            pdf.set_xy(px - 3, y_top - 7)
            pdf.cell(6, 3, "P", align="C")

    # Point loads on overhang
    if point_loads_cant:
        pdf.set_draw_color(200, 0, 0)
        pdf.set_line_width(0.4)
        for pl in point_loads_cant:
            px = x_R2 + (pl.get("a_m", 0) / a_m) * a_w
            pdf.line(px, y_top - 3, px, y_beam)
            pdf.line(px, y_beam, px - 1, y_beam - 2)
            pdf.line(px, y_beam, px + 1, y_beam - 2)
            pdf.set_font(pdf.FONT_SANS, "I", 6)
            pdf.set_text_color(200, 0, 0)
            pdf.set_xy(px - 3, y_top - 7)
            pdf.cell(6, 3, "P", align="C")

    pdf.set_draw_color(*CLR_BLACK)
    pdf.set_text_color(*CLR_BLACK)
    pdf.set_line_width(0.3)

    pdf.set_y(y_dim2 + 4)


def _render_load_table(pdf, load_entries, sw_kn_m, density_val, table_label=None):
    """Render a load entries table with self-weight row and totals."""
    if table_label:
        pdf.calc_line(table_label)
    if not load_entries or len(load_entries) == 0:
        return
    pdf.set_font(pdf.FONT_SANS, "B", 6.5)
    col_w = [32, 22, 22, 22, 22, 22, 22]
    headers = ["Load Type", "G (kPa)", "Q (kPa)", "Trib (m)",
                "G (kN/m)", "Q (kN/m)", "UDL (kN/m)"]
    for i, h in enumerate(headers):
        pdf.cell(col_w[i], 4, h, border=1, align="C")
    pdf.ln()

    pdf.set_font(pdf.FONT_MONO, "", 6.5)
    total_G = 0.0
    total_Q = 0.0
    total_udl = 0.0
    for entry in load_entries:
        e_G = entry.get("G_line", entry["dead"] * entry.get("trib", 0.6))
        e_Q = entry.get("Q_line", entry["live"] * entry.get("trib", 0.6))
        e_udl = entry.get("udl", (entry["dead"] + entry["live"]) * entry.get("trib", 0.6))
        total_G += e_G
        total_Q += e_Q
        total_udl += e_udl
        row = [
            entry["type"],
            f"{entry['dead']:.2f}",
            f"{entry['live']:.2f}",
            f"{entry.get('trib', 0.6):.2f}",
            f"{e_G:.3f}",
            f"{e_Q:.3f}",
            f"{e_udl:.3f}",
        ]
        for i, val in enumerate(row):
            pdf.cell(col_w[i], 4, val, border=1, align="C")
        pdf.ln()

    if sw_kn_m > 0:
        pdf.set_font(pdf.FONT_MONO, "I", 6.5)
        sw_row = ["Self-Weight", "-", "-", "-",
                  f"{sw_kn_m:.3f}", "0.000", f"{sw_kn_m:.3f}"]
        for i, val in enumerate(sw_row):
            pdf.cell(col_w[i], 4, val, border=1, align="C")
        pdf.ln()
        total_G += sw_kn_m
        total_udl += sw_kn_m

    pdf.set_font(pdf.FONT_SANS, "B", 6.5)
    pdf.cell(col_w[0], 4, "TOTAL", border=1, align="C")
    pdf.cell(col_w[1], 4, "", border=1, align="C")
    pdf.cell(col_w[2], 4, "", border=1, align="C")
    pdf.cell(col_w[3], 4, "", border=1, align="C")
    pdf.cell(col_w[4], 4, f"{total_G:.3f}", border=1, align="C")
    pdf.cell(col_w[5], 4, f"{total_Q:.3f}", border=1, align="C")
    pdf.cell(col_w[6], 4, f"{total_udl:.3f}", border=1, align="C")
    pdf.ln()


def _render_single_beam(pdf, inputs, beam_actions, section, grade_name,
                         grade, results, k_factors, load_entries, line_loads):
    """Render all sections for a single beam onto the given pdf object."""
    phi = grade.get("phi", 0.8)
    k2 = grade.get("k2", 2.0)
    k1 = k_factors.get("k1", 0.8)
    k6_val = k_factors.get("k6", 1.0)
    k7_val = k_factors.get("k7", 1.0)
    k9_val = k_factors.get("k9", 1.0)
    k12_val = k_factors.get("k12", 1.0)
    span = inputs["span_m"]
    bearing_mm = inputs.get("bearing_length_mm", 50)
    defl_limit = inputs.get("deflection_limit", 300)

    # Get line loads values (back span for overhanging)
    if line_loads:
        G_line = line_loads.G
        Q_line = line_loads.Q
        w_uls = line_loads.w_uls
        w_sls_short = line_loads.w_sls_short
        w_sls_long = line_loads.w_sls_long
        uls_label = line_loads.uls_combo_label
    else:
        w_sls_short = beam_actions.w_sls_short
        w_sls_long = beam_actions.w_sls_long
        w_uls = beam_actions.w_uls
        if w_sls_short > w_sls_long:
            Q_line = (w_sls_short - w_sls_long) / 0.3
        else:
            Q_line = 0.0
        G_line = w_sls_long - 0.4 * Q_line
        uls_label = "1.2G + 1.5Q" if 1.2 * G_line + 1.5 * Q_line > 1.35 * G_line else "1.35G"

    beam_type = inputs.get("beam_type", SIMPLY_SUPPORTED)
    is_overhanging = beam_type == OVERHANGING
    support_label = "Overhanging One Support" if is_overhanging else "Simply Supported"

    # Overhanging beam specifics
    ell = inputs.get("back_span_m", span)
    a_cant = inputs.get("cant_span_m", 0.0)
    w_uls_cant = inputs.get("w_uls_cant", 0.0)
    G_cant = inputs.get("G_cant", 0.0)
    Q_cant = inputs.get("Q_cant", 0.0)
    uls_label_cant = inputs.get("uls_combo_label_cant", "")
    w_sls_short_cant = inputs.get("w_sls_short_cant", 0.0)
    w_sls_long_cant = inputs.get("w_sls_long_cant", 0.0)

    # Point loads
    point_loads_ss = inputs.get("point_loads", [])
    point_loads_back = inputs.get("point_loads_back", [])
    point_loads_cant = inputs.get("point_loads_cant", [])
    has_pl_back = bool(point_loads_back)
    has_pl_cant = bool(point_loads_cant)
    has_point_loads = bool(point_loads_ss) or has_pl_back or has_pl_cant

    sw_kn_m = inputs.get("self_weight_kn_m", 0.0)
    density_val = inputs.get("density_kg_m3", 0.0)

    # ═══════════════════════════════════════════════════════════════
    # SECTION 1 — Project Information
    # ═══════════════════════════════════════════════════════════════
    pdf.section_heading(1, "Project Information")
    pdf.info_line("Project Name:", inputs.get("project_name", "N/A"))
    pdf.info_line("Project Number:", inputs.get("project_number", "N/A"))
    pdf.info_line("Project Address:", inputs.get("project_address", "N/A"))
    pdf.info_line("Beam ID:", inputs.get("beam_id", "N/A"))
    pdf.info_line("Designer:", inputs.get("designer", "N/A"))
    pdf.info_line("Date:", inputs.get("date", date.today().isoformat()))

    # ═══════════════════════════════════════════════════════════════
    # SECTION 2 — Input Summary
    # ═══════════════════════════════════════════════════════════════
    pdf.section_heading(2, "Input Summary")

    pdf.sub_heading("2.1  Geometry & Material")
    if is_overhanging:
        pdf.calc_expression("Total Span, L", f"= {span:.2f} m")
        pdf.calc_expression("Back Span, ell = L - a", f"= {ell:.2f} m")
        pdf.calc_expression("Overhang, a", f"= {a_cant:.2f} m")
    else:
        pdf.calc_expression("Span, L", f"= {span:.2f} m")
    pdf.calc_expression("Support Conditions", f"= {support_label}")
    pdf.calc_expression("Timber Grade", f"= {grade_name}")
    pdf.calc_expression("Section b x d", f"= {section.b:.0f} x {section.d:.0f} mm")
    pdf.calc_expression("f'b", f"= {grade['fb']:.1f} MPa")
    if grade.get('fs'):
        pdf.calc_expression("f's", f"= {grade['fs']} MPa")
    if grade.get('fp'):
        pdf.calc_expression("f'p", f"= {grade['fp']} MPa")
    pdf.calc_expression("E", f"= {grade['E']:.0f} MPa")
    pdf.calc_expression("phi (ZZ2.3)", f"= {phi}")
    pdf.calc_expression("k1 (duration, Table 2.3)", f"= {k1} ({inputs.get('load_duration', '')})")
    pdf.calc_expression("k2 (creep)", f"= {k2}")
    pdf.thin_rule()

    # Beam diagram
    if is_overhanging:
        _draw_beam_diagram_overhanging(pdf, ell, a_cant,
                                        point_loads_back, point_loads_cant)
    else:
        _draw_beam_diagram_ss(pdf, span, point_loads_ss)
    pdf.ln(1)

    # 2.2 Applied Loads
    if is_overhanging:
        pdf.sub_heading("2.2a  Applied Loads -- Back Span")
        _render_load_table(pdf, load_entries, sw_kn_m, density_val)
        pdf.ln(1)

        load_entries_cant = inputs.get("load_entries_cant", [])
        if load_entries_cant:
            pdf.sub_heading("2.2b  Applied Loads -- Overhang")
            _render_load_table(pdf, load_entries_cant, sw_kn_m, density_val)
            pdf.ln(1)
    else:
        pdf.sub_heading("2.2  Applied Loads (UDL)")
        _render_load_table(pdf, load_entries, sw_kn_m, density_val)

    # Point loads table
    if point_loads_ss and not is_overhanging:
        pdf.ln(1)
        pdf.sub_heading("2.2b  Point Loads")
        pdf.set_font(pdf.FONT_SANS, "B", 6.5)
        pl_col_w = [20, 30, 30, 30, 30]
        pl_headers = ["Load", "P_ULS (kN)", "P_SLS (kN)", "a (m)", "b (m)"]
        for i, h in enumerate(pl_headers):
            pdf.cell(pl_col_w[i], 4, h, border=1, align="C")
        pdf.ln()
        pdf.set_font(pdf.FONT_MONO, "", 6.5)
        for pl in point_loads_ss:
            row = [pl["label"], f"{pl['P_uls']:.2f}", f"{pl['P_sls']:.2f}",
                   f"{pl['a_m']:.2f}", f"{pl['b_m']:.2f}"]
            for i, val in enumerate(row):
                pdf.cell(pl_col_w[i], 4, val, border=1, align="C")
            pdf.ln()
        pdf.ln(1)

    if is_overhanging and (has_pl_back or has_pl_cant):
        pdf.ln(1)
        pdf.sub_heading("2.2c  Point Loads")
        pdf.set_font(pdf.FONT_SANS, "B", 6.5)
        pl_col_w = [25, 25, 25, 25, 25, 25]
        pl_headers = ["Load", "Location", "P_ULS(kN)", "P_SLS(kN)", "a (m)", "b (m)"]
        for i, h in enumerate(pl_headers):
            pdf.cell(pl_col_w[i], 4, h, border=1, align="C")
        pdf.ln()
        pdf.set_font(pdf.FONT_MONO, "", 6.5)
        for pl in point_loads_back:
            row = [pl["label"], "Back span", f"{pl['P_uls']:.2f}",
                   f"{pl['P_sls']:.2f}", f"{pl['a_m']:.2f}", f"{pl['b_m']:.2f}"]
            for i, val in enumerate(row):
                pdf.cell(pl_col_w[i], 4, val, border=1, align="C")
            pdf.ln()
        for pl in point_loads_cant:
            row = [pl["label"], "Overhang", f"{pl['P_uls']:.2f}",
                   f"{pl['P_sls']:.2f}", f"{pl['a_m']:.2f}", f"{pl['b_m']:.2f}"]
            for i, val in enumerate(row):
                pdf.cell(pl_col_w[i], 4, val, border=1, align="C")
            pdf.ln()
        pdf.ln(1)

    pdf.ln(1)
    pdf.info_line("Load Duration:", inputs.get("load_duration", "N/A"))
    pdf.info_line("Bearing Length:", f"{bearing_mm:.0f} mm")
    if is_overhanging:
        defl_limit_tip = inputs.get("deflection_limit_tip", 150)
        pdf.info_line("Deflection Limit (back span):", f"ell/{defl_limit}")
        pdf.info_line("Deflection Limit (overhang tip):", f"a/{defl_limit_tip}")
    else:
        pdf.info_line("Deflection Limit:", f"L/{defl_limit}")
    pdf.thin_rule()

    # 2.3 Design Line Loads
    pdf.sub_heading("2.3  Design Line Loads")
    if sw_kn_m > 0:
        pdf.calc_expression(
            f"Beam self-weight ({density_val:.0f} kg/m3)",
            f"= {sw_kn_m:.3f} kN/m")

    if is_overhanging:
        pdf.calc_line("Back Span:")
        pdf.calc_expression("G (dead incl. self-wt)", f"= {G_line:.3f} kN/m")
        pdf.calc_expression("Q (live)", f"= {Q_line:.3f} kN/m")
        pdf.calc_expression(f"w*_back = {uls_label}", f"= {w_uls:.3f} kN/m")
        pdf.calc_expression("w_SLS_short = G + 0.7Q", f"= {w_sls_short:.3f} kN/m")
        pdf.calc_expression("w_SLS_long  = G + 0.4Q", f"= {w_sls_long:.3f} kN/m")
        pdf.ln(1)
        pdf.calc_line("Overhang:")
        pdf.calc_expression("G_cant (dead incl. self-wt)", f"= {G_cant:.3f} kN/m")
        pdf.calc_expression("Q_cant (live)", f"= {Q_cant:.3f} kN/m")
        pdf.calc_expression(f"w*_cant = {uls_label_cant}", f"= {w_uls_cant:.3f} kN/m")
        pdf.calc_expression("w_SLS_short_cant", f"= {w_sls_short_cant:.3f} kN/m")
        pdf.calc_expression("w_SLS_long_cant", f"= {w_sls_long_cant:.3f} kN/m")
    else:
        pdf.calc_expression("G (total dead incl. self-wt)", f"= {G_line:.3f} kN/m")
        pdf.calc_expression("Q (total live line load)", f"= {Q_line:.3f} kN/m")
        pdf.calc_expression(f"w* = {uls_label}", f"= {w_uls:.3f} kN/m")
        pdf.calc_expression("w_SLS_short = G + 0.7Q", f"= {w_sls_short:.3f} kN/m")
        pdf.calc_expression("w_SLS_long  = G + 0.4Q", f"= {w_sls_long:.3f} kN/m")

    # ═══════════════════════════════════════════════════════════════
    # SECTION 3 — Calculation Working
    # ═══════════════════════════════════════════════════════════════
    pdf.section_heading(3, "Calculation Working")

    # 3.1 Section Properties
    pdf.sub_heading("3.1  Section Properties")
    pdf.calc_expression(f"A  = b x d = {section.b:.0f} x {section.d:.0f}",
                        f"= {section.area:.0f} mm2")
    pdf.calc_expression(f"Zx = b.d2/6 = {section.b:.0f} x {section.d:.0f}2 / 6",
                        f"= {section.Zx:.0f} mm3")
    pdf.calc_expression(f"Ix = b.d3/12 = {section.b:.0f} x {section.d:.0f}3 / 12",
                        f"= {section.Ix:.0f} mm4")
    pdf.thin_rule()

    # 3.2 Beam Actions
    if is_overhanging:
        load_desc = "UDL + Point Loads" if has_point_loads else "UDL"
        pdf.sub_heading(f"3.2  Beam Actions ({support_label}, {load_desc})")

        # Case A: UDL on back span
        pdf.calc_line("Case A: UDL on back span (between R1 and R2)")
        M_sag_A = w_uls * ell ** 2 / 8.0
        R1_A = w_uls * ell / 2.0
        pdf.calc_expression(
            f"M_sag = w_back*ell2/8 = {w_uls:.3f} x {ell:.2f}2 / 8",
            f"= {M_sag_A:.2f} kNm")
        pdf.calc_expression(
            f"R1_A = R2_A = w_back*ell/2 = {w_uls:.3f} x {ell:.2f} / 2",
            f"= {R1_A:.2f} kN")

        # Case B: UDL on overhang
        if w_uls_cant > 0:
            pdf.ln(1)
            pdf.calc_line("Case B: UDL on overhang")
            M_hog_B = w_uls_cant * a_cant ** 2 / 2.0
            R1_B = w_uls_cant * a_cant ** 2 / (2.0 * ell)
            R2_B = w_uls_cant * a_cant * (2.0 * ell + a_cant) / (2.0 * ell)
            pdf.calc_expression(
                f"M_hog = w_cant*a2/2 = {w_uls_cant:.3f} x {a_cant:.2f}2 / 2",
                f"= {M_hog_B:.2f} kNm")
            pdf.calc_expression(
                f"R1_B = -w_cant*a2/(2ell) = -{w_uls_cant:.3f}*{a_cant:.2f}2/(2*{ell:.2f})",
                f"= -{R1_B:.2f} kN (uplift)")
            pdf.calc_expression(
                f"R2_B = w_cant*a*(2ell+a)/(2ell)",
                f"= {R2_B:.2f} kN")

        # Point loads
        if has_pl_back:
            pdf.ln(1)
            pdf.calc_line("Case D: Point load(s) on back span")
            for pl in point_loads_back:
                P = pl["P_uls"]
                a_pl = pl["a_m"]
                b_pl = pl["b_m"]
                M_pl = P * a_pl * b_pl / ell
                R1_pl = P * b_pl / ell
                R2_pl = P * a_pl / ell
                pdf.calc_expression(
                    f"{pl['label']}: M=Pab/ell = {P:.2f}x{a_pl:.2f}x{b_pl:.2f}/{ell:.2f}",
                    f"= {M_pl:.2f} kNm")
                pdf.calc_expression(
                    f"  R1 = Pb/ell = {P:.2f}x{b_pl:.2f}/{ell:.2f}",
                    f"= {R1_pl:.2f} kN")

        if has_pl_cant:
            pdf.ln(1)
            pdf.calc_line("Case C: Point load(s) on overhang")
            for pl in point_loads_cant:
                P = pl["P_uls"]
                x1 = pl["a_m"]
                M_hog_pl = P * x1
                R1_pl = P * x1 / ell
                R2_pl = P * (ell + x1) / ell
                pdf.calc_expression(
                    f"{pl['label']}: M_hog = P*x1 = {P:.2f} x {x1:.2f}",
                    f"= {M_hog_pl:.2f} kNm")
                pdf.calc_expression(
                    f"  R1 = -P*x1/ell = -{P:.2f}*{x1:.2f}/{ell:.2f}",
                    f"= -{R1_pl:.2f} kN (uplift)")
                pdf.calc_expression(
                    f"  R2 = P*(ell+x1)/ell",
                    f"= {R2_pl:.2f} kN")

        pdf.ln(1)
        pdf.calc_line("Combined results (superposition):")
        pdf.calc_expression("M* (sagging)", f"= {beam_actions.M_sagging:.2f} kNm")
        pdf.calc_expression("M* (hogging at R2)", f"= {beam_actions.M_hogging:.2f} kNm")
        pdf.calc_expression("R1", f"= {beam_actions.R_left:.2f} kN")
        pdf.calc_expression("R2", f"= {beam_actions.R_right:.2f} kN")
        pdf.calc_expression("V*_max", f"= {beam_actions.V_star:.2f} kN")
        if beam_actions.R_left < 0:
            pdf.calc_line("** R1 is in UPLIFT -- hold-down connection required **")

    else:
        # Simply Supported
        load_desc = "UDL + Point Loads" if has_point_loads else "UDL"
        pdf.sub_heading(f"3.2  Beam Actions ({support_label}, {load_desc})")

        M_udl = w_uls * span ** 2 / 8.0
        V_udl = w_uls * span / 2.0
        pdf.calc_expression(f"M_udl = w*.L2/8 = {w_uls:.3f} x {span:.2f}2 / 8",
                            f"= {M_udl:.2f} kNm")
        pdf.calc_expression(f"V_udl = w*.L/2  = {w_uls:.3f} x {span:.2f} / 2",
                            f"= {V_udl:.2f} kN")

        if point_loads_ss:
            pdf.ln(1)
            pdf.calc_line("Point Load Actions (superposition):")
            for pl in point_loads_ss:
                a_pl = pl["a_m"]
                b_pl = pl["b_m"]
                P = pl["P_uls"]
                M_pl = P * a_pl * b_pl / span
                Ra = P * b_pl / span
                Rb = P * a_pl / span
                pdf.calc_expression(
                    f"{pl['label']}: M = P.a.b/L = {P:.2f} x {a_pl:.2f} x {b_pl:.2f} / {span:.2f}",
                    f"= {M_pl:.2f} kNm")
                pdf.calc_expression(
                    f"  Ra = P.b/L = {P:.2f} x {b_pl:.2f} / {span:.2f}",
                    f"= {Ra:.2f} kN")
                pdf.calc_expression(
                    f"  Rb = P.a/L = {P:.2f} x {a_pl:.2f} / {span:.2f}",
                    f"= {Rb:.2f} kN")
            pdf.ln(1)
            pdf.calc_line("Total actions (superposition):")

        pdf.calc_expression("M*_total", f"= {beam_actions.M_star:.2f} kNm")
        pdf.calc_expression("V*_max", f"= {beam_actions.V_star:.2f} kN")
        pdf.calc_expression("R_max", f"= {beam_actions.R_max:.2f} kN")

        if point_loads_ss:
            pdf.calc_expression("R_left", f"= {beam_actions.R_left:.2f} kN")
            pdf.calc_expression("R_right", f"= {beam_actions.R_right:.2f} kN")

    pdf.thin_rule()

    # 3.3 Bending — Eq. 3.2(2)
    fb = grade["fb"]
    Zx = section.Zx
    phi_Mx = phi * float(k1) * K4_DRY * float(k6_val) * float(k9_val) * float(k12_val) * fb * Zx
    phi_Mx_knm = phi_Mx / 1e6

    if is_overhanging:
        pdf.sub_heading("3.3a  Bending (Sagging) Check  [Eq. 3.2(2)]")
        pdf.calc_line(f"Md = phi x k1 x k4 x k6 x k9 x k12 x f'b x Zx")
        pdf.calc_expression(
            f"= {phi} x {k1} x {K4_DRY} x {k6_val} x {k9_val} x {k12_val} x {fb} x {Zx:.0f}",
            f"= {phi_Mx_knm:.2f} kNm")
        sag_util = beam_actions.M_sagging / phi_Mx_knm * 100 if phi_Mx_knm > 0 else 999
        sag_pass = sag_util <= 100
        pdf.calc_result_line(
            f"M_sag / Md = {beam_actions.M_sagging:.2f} / {phi_Mx_knm:.2f} = {sag_util:.0f}%  "
            f"[{'PASS' if sag_pass else 'FAIL'}]",
            passed=sag_pass)
        pdf.thin_rule()

        pdf.sub_heading("3.3b  Bending (Hogging) Check  [Eq. 3.2(2)]")
        hog_util = beam_actions.M_hogging / phi_Mx_knm * 100 if phi_Mx_knm > 0 else 999
        hog_pass = hog_util <= 100
        pdf.calc_result_line(
            f"M_hog / Md = {beam_actions.M_hogging:.2f} / {phi_Mx_knm:.2f} = {hog_util:.0f}%  "
            f"[{'PASS' if hog_pass else 'FAIL'}]",
            passed=hog_pass)
    else:
        pdf.sub_heading("3.3  Bending Capacity Check  [Eq. 3.2(2)]")
        pdf.calc_line(f"Md = phi x k1 x k4 x k6 x k9 x k12 x f'b x Zx")
        pdf.calc_expression(
            f"= {phi} x {k1} x {K4_DRY} x {k6_val} x {k9_val} x {k12_val} x {fb} x {Zx:.0f}",
            f"= {phi_Mx_knm:.2f} kNm")
        bending_util = beam_actions.M_star / phi_Mx_knm * 100 if phi_Mx_knm > 0 else 999
        bending_pass = bending_util <= 100
        pdf.calc_result_line(
            f"M* / Md = {beam_actions.M_star:.2f} / {phi_Mx_knm:.2f} = {bending_util:.0f}%  "
            f"[{'PASS' if bending_pass else 'FAIL'}]",
            passed=bending_pass)
    pdf.thin_rule()

    # 3.4 Shear — Eq. 3.2(14)
    pdf.sub_heading("3.4  Shear Capacity Check  [Eq. 3.2(14)]")
    fs = grade.get("fs")
    if fs is not None:
        As = section.shear_area()
        phi_Vs = phi * float(k1) * K4_DRY * float(k6_val) * fs * As / 1e3
        pdf.calc_line(f"Vd = phi x k1 x k4 x k6 x f's x (2/3.b.d)")
        pdf.calc_expression(
            f"As = 2/3 x {section.b:.0f} x {section.d:.0f}",
            f"= {As:.0f} mm2")
        pdf.calc_expression(
            f"= {phi} x {k1} x {K4_DRY} x {k6_val} x {fs} x {As:.0f} / 1000",
            f"= {phi_Vs:.2f} kN")
        shear_util = beam_actions.V_star / phi_Vs * 100 if phi_Vs > 0 else 999
        shear_pass = shear_util <= 100
        pdf.calc_result_line(
            f"V* / Vd = {beam_actions.V_star:.2f} / {phi_Vs:.2f} = {shear_util:.0f}%  "
            f"[{'PASS' if shear_pass else 'FAIL'}]",
            passed=shear_pass)
    else:
        pdf.calc_line("Shear data not available for this grade -- check manually")
    pdf.thin_rule()

    # 3.5 Bearing — Eq. 3.2(16)
    fp = grade.get("fp")
    if is_overhanging:
        pdf.sub_heading("3.5a  Bearing at R1  [Eq. 3.2(16)]")
        if fp is not None:
            Ap = section.bearing_area(bearing_mm)
            phi_Np = phi * float(k1) * K4_DRY * float(k6_val) * float(k7_val) * fp * Ap / 1e3
            if beam_actions.R_left < 0:
                pdf.calc_line(
                    f"R1 = {beam_actions.R_left:.2f} kN (UPLIFT) -- no bearing, hold-down required")
                pdf.calc_result_line("Bearing at R1: N/A (uplift)", passed=True)
            else:
                R1_abs = abs(beam_actions.R_left)
                pdf.calc_line(f"Nd,p = phi x k1 x k4 x k6 x k7 x f'p x Ap")
                pdf.calc_expression(f"Ap = {bearing_mm:.0f} x {section.b:.0f}", f"= {Ap:.0f} mm2")
                pdf.calc_expression(
                    f"= {phi} x {k1} x {K4_DRY} x {k6_val} x {k7_val} x {fp} x {Ap:.0f} / 1000",
                    f"= {phi_Np:.2f} kN")
                b_util = R1_abs / phi_Np * 100 if phi_Np > 0 else 999
                b_pass = b_util <= 100
                pdf.calc_result_line(
                    f"R1 / Nd,p = {R1_abs:.2f} / {phi_Np:.2f} = {b_util:.0f}%  "
                    f"[{'PASS' if b_pass else 'FAIL'}]",
                    passed=b_pass)
        else:
            pdf.calc_line("Bearing data not available -- check manually")
        pdf.thin_rule()

        pdf.sub_heading("3.5b  Bearing at R2  [Eq. 3.2(16)]")
        if fp is not None:
            R2_abs = abs(beam_actions.R_right)
            pdf.calc_line(f"Nd,p = phi x k1 x k4 x k6 x k7 x f'p x Ap")
            pdf.calc_expression(f"Ap = {bearing_mm:.0f} x {section.b:.0f}", f"= {Ap:.0f} mm2")
            pdf.calc_expression(
                f"= {phi} x {k1} x {K4_DRY} x {k6_val} x {k7_val} x {fp} x {Ap:.0f} / 1000",
                f"= {phi_Np:.2f} kN")
            b_util = R2_abs / phi_Np * 100 if phi_Np > 0 else 999
            b_pass = b_util <= 100
            pdf.calc_result_line(
                f"R2 / Nd,p = {R2_abs:.2f} / {phi_Np:.2f} = {b_util:.0f}%  "
                f"[{'PASS' if b_pass else 'FAIL'}]",
                passed=b_pass)
        else:
            pdf.calc_line("Bearing data not available -- check manually")
    else:
        pdf.sub_heading("3.5  Bearing Capacity Check  [Eq. 3.2(16)]")
        if fp is not None:
            Ap = section.bearing_area(bearing_mm)
            phi_Np = phi * float(k1) * K4_DRY * float(k6_val) * float(k7_val) * fp * Ap / 1e3
            pdf.calc_line(f"Nd,p = phi x k1 x k4 x k6 x k7 x f'p x Ap")
            pdf.calc_expression(
                f"Ap = lb x b = {bearing_mm:.0f} x {section.b:.0f}", f"= {Ap:.0f} mm2")
            pdf.calc_expression(
                f"= {phi} x {k1} x {K4_DRY} x {k6_val} x {k7_val} x {fp} x {Ap:.0f} / 1000",
                f"= {phi_Np:.2f} kN")
            bearing_util = beam_actions.R_max / phi_Np * 100 if phi_Np > 0 else 999
            bearing_pass = bearing_util <= 100
            pdf.calc_result_line(
                f"R / Nd,p = {beam_actions.R_max:.2f} / {phi_Np:.2f} = {bearing_util:.0f}%  "
                f"[{'PASS' if bearing_pass else 'FAIL'}]",
                passed=bearing_pass)
        else:
            pdf.calc_line("Bearing data not available for this grade -- check manually")
    pdf.thin_rule()

    # 3.6 Deflection Check
    from .beam_analysis import (
        calc_deflection, calc_deflection_point_load,
        calc_total_deflection_overhang_between,
        calc_total_deflection_overhang_tip,
    )
    E = grade["E"]
    Ix = section.Ix

    if is_overhanging:
        # 3.6a Back span deflection
        pdf.sub_heading("3.6a  Deflection -- Back Span (midspan between supports)")
        allowable_back = ell * 1000.0 / defl_limit
        pdf.calc_expression("E", f"= {E:.0f} MPa")
        pdf.calc_expression("Ix", f"= {Ix:.0f} mm4")
        pdf.calc_expression(
            f"Allowable = ell/{defl_limit} = {ell*1000:.0f}/{defl_limit}",
            f"= {allowable_back:.1f} mm")
        pdf.ln(1)

        # Find deflection results from results list
        defl_results = [r for r in results if r.name.startswith("Defl.")]
        for dr in defl_results:
            if "back" in dr.name.lower():
                pdf.calc_result_line(
                    f"{dr.name}: {dr.demand:.2f} / {dr.capacity:.1f} = {dr.utilisation:.0f}%  "
                    f"[{'PASS' if dr.passed else 'FAIL'}]",
                    passed=dr.passed)
        pdf.thin_rule()

        # 3.6b Overhang tip deflection
        defl_limit_tip = inputs.get("deflection_limit_tip", 150)
        pdf.sub_heading("3.6b  Deflection -- Overhang Tip (free end)")
        allowable_tip = a_cant * 1000.0 / defl_limit_tip
        pdf.calc_expression(
            f"Allowable = a/{defl_limit_tip} = {a_cant*1000:.0f}/{defl_limit_tip}",
            f"= {allowable_tip:.1f} mm")
        pdf.ln(1)

        for dr in defl_results:
            if "overhang" in dr.name.lower():
                pdf.calc_result_line(
                    f"{dr.name}: {dr.demand:.2f} / {dr.capacity:.1f} = {dr.utilisation:.0f}%  "
                    f"[{'PASS' if dr.passed else 'FAIL'}]",
                    passed=dr.passed)
    else:
        # Simply supported deflection
        pdf.sub_heading("3.6  Deflection Check")
        allowable = span * 1000.0 / defl_limit
        pdf.calc_expression("E", f"= {E:.0f} MPa")
        pdf.calc_expression("Ix", f"= {Ix:.0f} mm4")
        pdf.calc_expression(
            f"Allowable = L/{defl_limit} = {span*1000:.0f}/{defl_limit}",
            f"= {allowable:.1f} mm")
        pdf.calc_expression("Deflection location", "= midspan")
        pdf.ln(1)

        _calc_udl_defl = calc_deflection
        _calc_pl_defl = calc_deflection_point_load

        # Short-term
        pdf.calc_line("Short-term: delta_st = 5.w.L4 / (384.E.I)")
        delta_st_udl = _calc_udl_defl(w_sls_short, span, E, Ix)
        pdf.calc_expression("w_short = G + 0.7Q", f"= {w_sls_short:.3f} kN/m")
        pdf.calc_expression(
            f"delta_udl = 5 x {w_sls_short:.3f} x ({span*1000:.0f})4 / (384 x {E:.0f} x {Ix:.0f})",
            f"= {delta_st_udl:.2f} mm")

        delta_st_total = delta_st_udl
        if point_loads_ss:
            pdf.ln(1)
            pdf.calc_line("Point load deflections (SLS): Pb(3L2-4b2)/(48EI)")
            for pl in point_loads_ss:
                d_pl = _calc_pl_defl(pl["P_sls"], pl["a_m"], span, E, Ix)
                delta_st_total += d_pl
                b_val = min(pl["a_m"], pl["b_m"])
                pdf.calc_expression(
                    f"{pl['label']}: P={pl['P_sls']:.2f}kN, b={b_val:.2f}m",
                    f"= {d_pl:.2f} mm")
            pdf.calc_expression("delta_st (total)", f"= {delta_st_total:.2f} mm")

        defl_st_util = delta_st_total / allowable * 100 if allowable > 0 else 999
        defl_st_pass = defl_st_util <= 100
        pdf.calc_result_line(
            f"delta_st / allow = {delta_st_total:.2f} / {allowable:.1f} = {defl_st_util:.0f}%  "
            f"[{'PASS' if defl_st_pass else 'FAIL'}]",
            passed=defl_st_pass)
        pdf.ln(1)

        # Long-term per NZS AS 1720.1 Cl 2.4.5.2
        pdf.calc_line(f"Long-term (Cl 2.4.5.2): delta_lt = k2 x delta(G) + delta(psi_l.Q),  k2 = {k2}")
        psi_lQ = 0.4 * Q_line
        delta_G = _calc_udl_defl(G_line, span, E, Ix)
        delta_psiQ = _calc_udl_defl(psi_lQ, span, E, Ix)
        pdf.calc_expression("G (dead)", f"= {G_line:.3f} kN/m")
        pdf.calc_expression("psi_l.Q = 0.4Q", f"= {psi_lQ:.3f} kN/m")
        pdf.calc_expression(
            f"delta(G) = 5 x {G_line:.3f} x ({span*1000:.0f})4 / (384 x {E:.0f} x {Ix:.0f})",
            f"= {delta_G:.2f} mm")
        pdf.calc_expression(
            f"delta(0.4Q) = 5 x {psi_lQ:.3f} x ({span*1000:.0f})4 / (384 x {E:.0f} x {Ix:.0f})",
            f"= {delta_psiQ:.2f} mm")

        delta_pl_lt = 0.0
        if point_loads_ss:
            for pl in point_loads_ss:
                d_pl = _calc_pl_defl(pl["P_sls"], pl["a_m"], span, E, Ix)
                delta_pl_lt += d_pl

        delta_lt = k2 * delta_G + delta_psiQ + delta_pl_lt
        pdf.calc_expression(
            f"delta_lt = k2 x delta(G) + delta(0.4Q) + PL = {k2} x {delta_G:.2f} + {delta_psiQ:.2f} + {delta_pl_lt:.2f}",
            f"= {delta_lt:.2f} mm")
        defl_lt_util = delta_lt / allowable * 100 if allowable > 0 else 999
        defl_lt_pass = defl_lt_util <= 100
        pdf.calc_result_line(
            f"delta_lt / allow = {delta_lt:.2f} / {allowable:.1f} = {defl_lt_util:.0f}%  "
            f"[{'PASS' if defl_lt_pass else 'FAIL'}]",
            passed=defl_lt_pass)

    # ═══════════════════════════════════════════════════════════════
    # SECTION 4 — Modification Factors Summary
    # ═══════════════════════════════════════════════════════════════
    pdf.section_heading(4, "Modification Factors (AS 1720.1:2022)")
    pdf.calc_expression("phi (Capacity factor, ZZ2.3)", f"= {phi}")
    pdf.calc_expression("k1  (Duration of load, Table 2.3)", f"= {k1}")
    pdf.calc_expression("k2  (Creep, per grade)", f"= {k2}")
    pdf.calc_expression("k4  (Moisture condition, Cl.2.4.2)", f"= {K4_DRY}")
    pdf.calc_expression("k6  (Temperature, Cl.2.4.3)", f"= {k6_val}")
    pdf.calc_expression("k7  (Bearing length, Table 2.6)", f"= {k7_val}")
    pdf.calc_expression("k9  (Strength sharing, Cl.2.4.5)", f"= {k9_val}")
    pdf.calc_expression("k12 (Stability, Cl.3.2.4)", f"= {k12_val}")

    # ═══════════════════════════════════════════════════════════════
    # SECTION 5 — Results Summary
    # ═══════════════════════════════════════════════════════════════
    # Estimate space needed: heading(~8) + header row(4.5) + data rows(4.5 each)
    # + gap(2) + verdict box(12) + margin
    results_height = 8 + 4.5 + len(results) * 4.5 + 2 + 12 + 4
    if pdf._space_left() < results_height:
        pdf.add_page()
    pdf.section_heading(5, "Results Summary")

    # Table
    pdf.set_font(pdf.FONT_SANS, "B", 7)
    col_w = [38, 24, 24, 18, 24, 20]
    headers = ["Check", "Demand", "Capacity", "Unit", "Util %", "Status"]
    pdf.set_fill_color(240, 242, 248)
    for i, h in enumerate(headers):
        pdf.cell(col_w[i], 4.5, h, border=1, align="C", fill=True)
    pdf.ln()

    pdf.set_font(pdf.FONT_MONO, "", 7)
    for r in results:
        status = "PASS" if r.passed else "FAIL"
        row = [
            r.name,
            f"{r.demand:.2f}",
            f"{r.capacity:.2f}",
            r.unit,
            f"{r.utilisation:.0f}%",
            status,
        ]
        for i, val in enumerate(row):
            if not r.passed and i == 5:
                pdf.set_text_color(*CLR_FAIL)
                pdf.set_font(pdf.FONT_MONO, "B", 7)
            elif i == 5:
                pdf.set_text_color(*CLR_PASS)
                pdf.set_font(pdf.FONT_MONO, "B", 7)
            pdf.cell(col_w[i], 4.5, val, border=1, align="C")
            pdf.set_text_color(*CLR_BLACK)
            pdf.set_font(pdf.FONT_MONO, "", 7)
        pdf.ln()
    pdf.ln(2)

    # Overall verdict box
    all_passed = all(r.passed for r in results)
    max_util = max(r.utilisation for r in results)

    pdf.set_font(pdf.FONT_SANS, "B", 14)
    x = pdf.get_x()
    y = pdf.get_y()
    if all_passed:
        pdf.set_fill_color(230, 248, 230)
        pdf.set_draw_color(*CLR_PASS)
        pdf.set_line_width(0.8)
        pdf.rect(x, y, 190, 12, style="DF")
        pdf.set_text_color(*CLR_PASS)
        pdf.set_xy(x, y + 1.5)
        pdf.cell(190, 9, f"DESIGN ADEQUATE -- Max utilisation {max_util:.0f}%",
                 align="C")
    else:
        pdf.set_fill_color(255, 230, 230)
        pdf.set_draw_color(*CLR_FAIL)
        pdf.set_line_width(0.8)
        pdf.rect(x, y, 190, 12, style="DF")
        pdf.set_text_color(*CLR_FAIL)
        pdf.set_xy(x, y + 1.5)
        failing = [r.name for r in results if not r.passed]
        pdf.cell(190, 9,
                 f"DESIGN INADEQUATE -- Failing: {', '.join(failing)}",
                 align="C")

    pdf.set_text_color(*CLR_BLACK)
    pdf.set_draw_color(*CLR_BLACK)
    pdf.set_line_width(0.3)


def generate_report(filepath: str, inputs: dict, beam_actions,
                    section, grade_name: str, grade: dict,
                    results: list, k_factors: dict,
                    load_entries: list = None,
                    line_loads=None) -> str:
    """Generate a Mathcad-inspired engineering PDF design report for a single beam."""

    logo_path = _get_logo_path()

    project_info = {
        "project_name": inputs.get("project_name", ""),
        "project_number": inputs.get("project_number", ""),
        "project_address": inputs.get("project_address", ""),
        "beam_id": inputs.get("beam_id", ""),
        "designer": inputs.get("designer", ""),
        "date": inputs.get("date", date.today().isoformat()),
    }

    pdf = TimberBeamReport(project_info, logo_path)
    pdf.alias_nb_pages()
    pdf.add_page()
    pdf.set_auto_page_break(auto=True, margin=20)

    _render_single_beam(pdf, inputs, beam_actions, section, grade_name,
                         grade, results, k_factors, load_entries, line_loads)

    pdf.output(filepath)

    try:
        os.unlink(logo_path)
    except OSError:
        pass

    return filepath


def generate_multi_beam_report(filepath: str, beams_data: list) -> str:
    """
    Generate a multi-beam PDF report.
    Page 1: Summary comparison table of all beams.
    Subsequent pages: Individual beam calculations (one per beam).
    """
    first_inputs = beams_data[0].get("inputs_dict", {})
    project_info = {
        "project_name": first_inputs.get("project_name", ""),
        "project_number": first_inputs.get("project_number", ""),
        "project_address": first_inputs.get("project_address", ""),
        "beam_id": "Multi-Beam Summary",
        "designer": first_inputs.get("designer", ""),
        "date": first_inputs.get("date", date.today().isoformat()),
    }

    logo_path = _get_logo_path()
    pdf = TimberBeamReport(project_info, logo_path)
    pdf.alias_nb_pages()
    pdf.add_page()
    pdf.set_auto_page_break(auto=True, margin=20)

    # ── Summary Comparison Table ──
    pdf.section_heading(1, "Multi-Beam Design Summary")

    num_beams = len(beams_data)
    param_col_w = 40
    beam_col_w = min(30, int((190 - param_col_w) / num_beams))

    pdf.set_font(pdf.FONT_SANS, "B", 7)
    pdf.set_fill_color(240, 242, 248)
    pdf.cell(param_col_w, 4.5, "Parameter", border=1, align="C", fill=True)
    for b in beams_data:
        pdf.cell(beam_col_w, 4.5, b["name"], border=1, align="C", fill=True)
    pdf.ln()

    rows = [
        ("Span (m)", [f"{b.get('span_m', 0):.2f}" for b in beams_data]),
        ("Section (mm)", [f"{b.get('beam_b', 0):.0f}x{b.get('beam_d', 0):.0f}" for b in beams_data]),
        ("Grade", [b.get("grade_name", "N/A") for b in beams_data]),
        ("M* (kNm)", [f"{b['beam_actions'].M_star:.2f}" if b.get("beam_actions") else "N/A" for b in beams_data]),
        ("V* (kN)", [f"{b['beam_actions'].V_star:.2f}" if b.get("beam_actions") else "N/A" for b in beams_data]),
        ("R_max (kN)", [f"{b['beam_actions'].R_max:.2f}" if b.get("beam_actions") else "N/A" for b in beams_data]),
        ("Max Util", [f"{b.get('max_util', 0):.0f}%" for b in beams_data]),
        ("Status", ["PASS" if b.get("all_passed") else "FAIL" for b in beams_data]),
    ]

    pdf.set_font(pdf.FONT_MONO, "", 7)
    for label, values in rows:
        pdf.cell(param_col_w, 4.5, label, border=1, align="L")
        for val in values:
            if label == "Status":
                color = CLR_PASS if val == "PASS" else CLR_FAIL
                pdf.set_text_color(*color)
                pdf.set_font(pdf.FONT_MONO, "B", 7)
            pdf.cell(beam_col_w, 4.5, val, border=1, align="C")
            pdf.set_text_color(*CLR_BLACK)
            pdf.set_font(pdf.FONT_MONO, "", 7)
        pdf.ln()

    # ── Individual Beam Pages ──
    for b in beams_data:
        if b.get("results") is None:
            continue
        pdf.add_page()

        pdf.set_font(pdf.FONT_SANS, "B", 11)
        pdf.set_text_color(*CLR_HEADING)
        pdf.cell(0, 7, f"--- {b['name']} ---", align="C",
                 new_x="LMARGIN", new_y="NEXT")
        pdf.set_text_color(*CLR_BLACK)
        pdf.ln(1)

        _render_single_beam(
            pdf,
            b.get("inputs_dict", {}),
            b["beam_actions"],
            b["section"],
            b.get("grade_name", "N/A"),
            b["grade"],
            b["results"],
            b.get("k_factors", {}),
            b.get("load_entries_for_pdf", []),
            b.get("line_loads"),
        )

    pdf.output(filepath)

    try:
        os.unlink(logo_path)
    except OSError:
        pass

    return filepath
