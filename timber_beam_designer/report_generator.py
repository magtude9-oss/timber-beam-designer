"""
Professional PDF report generator for timber beam design using fpdf2.
Mathcad-inspired style: formula-forward with expressions on the left,
evaluated results on the right, thin rule separators.
Variable names in muted grey, monospaced for calcs, sans-serif headings.
Subtle colour accents for section headers. B&W base overall.
"""

import base64
import tempfile
import os
from datetime import date
from fpdf import FPDF

from .logo_b64 import LOGO_B64
from .material_data import K4_DRY, K5_DEFAULT


# ── Colour constants ────────────────────────────────────────────────
CLR_HEADING = (40, 60, 90)       # muted blue-grey for section headings
CLR_VAR = (100, 100, 120)        # muted grey-blue for variable names
CLR_BLACK = (0, 0, 0)
CLR_PASS = (0, 100, 0)
CLR_FAIL = (200, 0, 0)
CLR_RULE = (180, 180, 180)       # light grey rules


def _get_logo_path():
    """Decode base64 logo to a temp file and return the path."""
    data = base64.b64decode(LOGO_B64)
    tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".png")
    tmp.write(data)
    tmp.close()
    return tmp.name


class TimberBeamReport(FPDF):
    """Mathcad-inspired engineering calculation report."""

    def __init__(self, project_info: dict, logo_path: str):
        super().__init__()
        self.project_info = project_info
        self.logo_path = logo_path

    def header(self):
        # Logo top-left
        if self.logo_path and os.path.exists(self.logo_path):
            self.image(self.logo_path, x=10, y=6, w=22)

        # Title
        self.set_font("Helvetica", "B", 13)
        self.set_text_color(*CLR_HEADING)
        self.cell(0, 7, "Timber Beam Design Calculation", align="C",
                  new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(*CLR_BLACK)

        # Project info top-right
        self.set_font("Helvetica", "", 7)
        info = self.project_info
        right_lines = [
            f"Project: {info.get('project_name', '')}",
            f"No: {info.get('project_number', '')}",
            f"Beam: {info.get('beam_id', '')}",
            f"Designer: {info.get('designer', '')}",
            f"Date: {info.get('date', '')}",
        ]
        y_start = 7
        for i, line in enumerate(right_lines):
            self.set_xy(135, y_start + i * 3.5)
            self.cell(65, 3.5, line, align="R")

        # Header rule
        self.set_y(27)
        self.set_draw_color(*CLR_HEADING)
        self.set_line_width(0.6)
        self.line(10, 27, 200, 27)
        self.set_draw_color(*CLR_BLACK)
        self.ln(4)

    def footer(self):
        self.set_y(-14)
        self.set_draw_color(*CLR_RULE)
        self.set_line_width(0.3)
        self.line(10, self.get_y(), 200, self.get_y())
        self.ln(1)
        self.set_font("Helvetica", "I", 6.5)
        self.set_text_color(100, 100, 100)
        info = self.project_info
        self.cell(90, 3.5, "Calculated by Magnitude Engineering", align="L")
        self.cell(0, 3.5, f"Page {self.page_no()}/{{nb}}", align="R",
                  new_x="LMARGIN", new_y="NEXT")
        self.set_font("Helvetica", "I", 5.5)
        self.cell(0, 3,
                  "This document is generated by automated calculation "
                  "-- verify inputs before use.",
                  align="C")
        self.set_text_color(*CLR_BLACK)

    # ── Formatting helpers ──────────────────────────────────────────

    def section_heading(self, number: int, title: str):
        """Numbered section heading with accent colour and rule."""
        self.ln(3)
        self.set_font("Helvetica", "B", 10.5)
        self.set_text_color(*CLR_HEADING)
        self.cell(0, 6, f"{number}.  {title}",
                  new_x="LMARGIN", new_y="NEXT")
        self.set_draw_color(*CLR_HEADING)
        self.set_line_width(0.4)
        self.line(10, self.get_y(), 200, self.get_y())
        self.set_draw_color(*CLR_BLACK)
        self.set_text_color(*CLR_BLACK)
        self.ln(2)

    def sub_heading(self, text: str):
        """Sub-heading within a section."""
        self.ln(1)
        self.set_font("Helvetica", "B", 9)
        self.set_text_color(*CLR_HEADING)
        self.cell(0, 5, text, new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(*CLR_BLACK)

    def info_line(self, label: str, value: str):
        """Label: value pair."""
        self.set_font("Helvetica", "B", 8)
        self.set_text_color(*CLR_VAR)
        self.cell(55, 4.5, label, new_x="RIGHT", new_y="LAST")
        self.set_font("Helvetica", "", 8)
        self.set_text_color(*CLR_BLACK)
        self.cell(0, 4.5, value, new_x="LMARGIN", new_y="NEXT")

    def calc_expression(self, formula: str, result: str):
        """Mathcad-style: formula left, result right, thin rule between."""
        y = self.get_y()
        # Formula (left, muted)
        self.set_font("Courier", "", 8)
        self.set_text_color(*CLR_VAR)
        self.cell(110, 4.5, f"  {formula}")
        # Thin vertical separator
        self.set_draw_color(*CLR_RULE)
        self.set_line_width(0.15)
        self.line(122, y, 122, y + 4.5)
        # Result (right, black, bold)
        self.set_font("Courier", "B", 8)
        self.set_text_color(*CLR_BLACK)
        self.set_xy(124, y)
        self.cell(0, 4.5, result, new_x="LMARGIN", new_y="NEXT")

    def calc_line(self, text: str):
        """Simple monospaced calculation line."""
        self.set_font("Courier", "", 8)
        self.set_text_color(*CLR_BLACK)
        self.cell(0, 4.5, f"  {text}", new_x="LMARGIN", new_y="NEXT")

    def calc_result_line(self, text: str, passed: bool = True):
        """Result line with pass/fail colour."""
        self.set_font("Courier", "B", 8)
        self.set_text_color(*(CLR_PASS if passed else CLR_FAIL))
        self.cell(0, 4.5, f"  {text}", new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(*CLR_BLACK)

    def thin_rule(self):
        """Light grey horizontal rule."""
        self.set_draw_color(*CLR_RULE)
        self.set_line_width(0.15)
        self.line(12, self.get_y(), 198, self.get_y())
        self.set_draw_color(*CLR_BLACK)
        self.ln(1.5)


def generate_report(filepath: str, inputs: dict, beam_actions,
                    section, grade_name: str, grade: dict,
                    results: list, k_factors: dict,
                    load_entries: list = None,
                    line_loads=None) -> str:
    """Generate a Mathcad-inspired engineering PDF design report."""

    logo_path = _get_logo_path()

    project_info = {
        "project_name": inputs.get("project_name", ""),
        "project_number": inputs.get("project_number", ""),
        "project_address": inputs.get("project_address", ""),
        "beam_id": inputs.get("beam_id", ""),
        "designer": inputs.get("designer", ""),
        "date": inputs.get("date", date.today().isoformat()),
    }

    pdf = TimberBeamReport(project_info, logo_path)
    pdf.alias_nb_pages()
    pdf.add_page()
    pdf.set_auto_page_break(auto=True, margin=20)

    phi = grade.get("phi", 0.8)
    k2 = grade.get("k2", 2.0)
    k1 = k_factors.get("k1", 0.77)
    k8_val = k_factors.get("k8", "1.000")
    k12_val = k_factors.get("k12", 1.0)
    k3_val = k_factors.get("k3", 1.0)
    span = inputs["span_m"]
    bearing_mm = inputs.get("bearing_length_mm", 50)
    defl_limit = inputs.get("deflection_limit", 300)

    # Get line loads values
    if line_loads:
        G_line = line_loads.G
        Q_line = line_loads.Q
        w_uls = line_loads.w_uls
        w_sls_short = line_loads.w_sls_short
        w_sls_long = line_loads.w_sls_long
        uls_label = line_loads.uls_combo_label
    else:
        w_sls_short = beam_actions.w_sls_short
        w_sls_long = beam_actions.w_sls_long
        w_uls = beam_actions.w_uls
        if w_sls_short > w_sls_long:
            Q_line = (w_sls_short - w_sls_long) / 0.3
        else:
            Q_line = 0.0
        G_line = w_sls_long - 0.4 * Q_line
        uls_label = "1.2G + 1.5Q" if 1.2 * G_line + 1.5 * Q_line > 1.35 * G_line else "1.35G"

    # ═══════════════════════════════════════════════════════════════
    # SECTION 1 — Project Information
    # ═══════════════════════════════════════════════════════════════
    pdf.section_heading(1, "Project Information")
    pdf.info_line("Project Name:", inputs.get("project_name", "N/A"))
    pdf.info_line("Project Number:", inputs.get("project_number", "N/A"))
    pdf.info_line("Project Address:", inputs.get("project_address", "N/A"))
    pdf.info_line("Beam ID:", inputs.get("beam_id", "N/A"))
    pdf.info_line("Designer:", inputs.get("designer", "N/A"))
    pdf.info_line("Date:", inputs.get("date", date.today().isoformat()))

    # ═══════════════════════════════════════════════════════════════
    # SECTION 2 — Input Summary
    # ═══════════════════════════════════════════════════════════════
    pdf.section_heading(2, "Input Summary")

    pdf.sub_heading("2.1  Geometry & Material")
    pdf.calc_expression("Span, L", f"= {span:.2f} m")
    pdf.calc_expression("Support Conditions", "= Simply Supported")
    pdf.calc_expression("Timber Grade", f"= {grade_name}")
    pdf.calc_expression("Section b x d", f"= {section.b:.0f} x {section.d:.0f} mm")
    pdf.calc_expression("f'b", f"= {grade['fb']:.1f} MPa")
    if grade.get('fs'):
        pdf.calc_expression("f's", f"= {grade['fs']} MPa")
    if grade.get('fp'):
        pdf.calc_expression("f'p", f"= {grade['fp']} MPa")
    pdf.calc_expression("E", f"= {grade['E']:.0f} MPa")
    pdf.calc_expression("phi", f"= {phi}")
    pdf.calc_expression("k1 (duration)", f"= {k1} ({inputs.get('load_duration', '')})")
    pdf.calc_expression("k2 (creep)", f"= {k2}")
    pdf.thin_rule()

    pdf.sub_heading("2.2  Applied Loads")
    if load_entries and len(load_entries) > 0:
        # Table header
        pdf.set_font("Helvetica", "B", 7.5)
        col_w = [32, 22, 22, 22, 22, 22, 22]
        headers = ["Load Type", "G (kPa)", "Q (kPa)", "Trib (m)",
                    "G (kN/m)", "Q (kN/m)", "UDL (kN/m)"]
        for i, h in enumerate(headers):
            pdf.cell(col_w[i], 4.5, h, border=1, align="C")
        pdf.ln()

        pdf.set_font("Courier", "", 7.5)
        total_G = 0.0
        total_Q = 0.0
        total_udl = 0.0
        for entry in load_entries:
            e_G = entry.get("G_line", entry["dead"] * entry.get("trib", 0.6))
            e_Q = entry.get("Q_line", entry["live"] * entry.get("trib", 0.6))
            e_udl = entry.get("udl", (entry["dead"] + entry["live"]) * entry.get("trib", 0.6))
            total_G += e_G
            total_Q += e_Q
            total_udl += e_udl
            row = [
                entry["type"],
                f"{entry['dead']:.2f}",
                f"{entry['live']:.2f}",
                f"{entry.get('trib', 0.6):.2f}",
                f"{e_G:.3f}",
                f"{e_Q:.3f}",
                f"{e_udl:.3f}",
            ]
            for i, val in enumerate(row):
                pdf.cell(col_w[i], 4.5, val, border=1, align="C")
            pdf.ln()

        # Beam self-weight row
        sw_kn_m = inputs.get("self_weight_kn_m", 0.0)
        density_val = inputs.get("density_kg_m3", 0.0)
        if sw_kn_m > 0:
            pdf.set_font("Courier", "I", 7.5)
            sw_row = ["Self-Weight", "-", "-", "-",
                      f"{sw_kn_m:.3f}", "0.000", f"{sw_kn_m:.3f}"]
            for i, val in enumerate(sw_row):
                pdf.cell(col_w[i], 4.5, val, border=1, align="C")
            pdf.ln()
            total_G += sw_kn_m
            total_udl += sw_kn_m

        # Totals
        pdf.set_font("Helvetica", "B", 7.5)
        pdf.cell(col_w[0], 4.5, "TOTAL", border=1, align="C")
        pdf.cell(col_w[1], 4.5, "", border=1, align="C")
        pdf.cell(col_w[2], 4.5, "", border=1, align="C")
        pdf.cell(col_w[3], 4.5, "", border=1, align="C")
        pdf.cell(col_w[4], 4.5, f"{total_G:.3f}", border=1, align="C")
        pdf.cell(col_w[5], 4.5, f"{total_Q:.3f}", border=1, align="C")
        pdf.cell(col_w[6], 4.5, f"{total_udl:.3f}", border=1, align="C")
        pdf.ln()

    pdf.ln(1)
    pdf.info_line("Load Duration:", inputs.get("load_duration", "N/A"))
    pdf.info_line("Bearing Length:", f"{bearing_mm:.0f} mm")
    pdf.info_line("Deflection Limit:", f"L/{defl_limit}")
    pdf.thin_rule()

    pdf.sub_heading("2.3  Design Line Loads")
    sw_kn_m = inputs.get("self_weight_kn_m", 0.0)
    density_val = inputs.get("density_kg_m3", 0.0)
    if sw_kn_m > 0:
        pdf.calc_expression(
            f"Beam self-weight ({density_val:.0f} kg/m3)",
            f"= {sw_kn_m:.3f} kN/m")
    pdf.calc_expression("G (total dead incl. self-wt)", f"= {G_line:.3f} kN/m")
    pdf.calc_expression("Q (total live line load)", f"= {Q_line:.3f} kN/m")
    pdf.calc_expression(f"w* = {uls_label}", f"= {w_uls:.3f} kN/m")
    pdf.calc_expression("w_SLS_short = G + 0.7Q", f"= {w_sls_short:.3f} kN/m")
    pdf.calc_expression("w_SLS_long  = G + 0.4Q", f"= {w_sls_long:.3f} kN/m")

    # ═══════════════════════════════════════════════════════════════
    # SECTION 3 — Calculation Working
    # ═══════════════════════════════════════════════════════════════
    pdf.section_heading(3, "Calculation Working")

    # 3.1 Section Properties
    pdf.sub_heading("3.1  Section Properties")
    pdf.calc_expression(f"A  = b x d = {section.b:.0f} x {section.d:.0f}",
                        f"= {section.area:.0f} mm2")
    pdf.calc_expression(f"Zx = b.d2/6 = {section.b:.0f} x {section.d:.0f}2 / 6",
                        f"= {section.Zx:.0f} mm3")
    pdf.calc_expression(f"Ix = b.d3/12 = {section.b:.0f} x {section.d:.0f}3 / 12",
                        f"= {section.Ix:.0f} mm4")
    pdf.thin_rule()

    # 3.2 Beam Actions
    pdf.sub_heading("3.2  Beam Actions (Simply Supported, UDL)")
    pdf.calc_expression(f"M* = w*.L2/8 = {w_uls:.3f} x {span:.2f}2 / 8",
                        f"= {beam_actions.M_star:.2f} kNm")
    pdf.calc_expression(f"V* = w*.L/2  = {w_uls:.3f} x {span:.2f} / 2",
                        f"= {beam_actions.V_star:.2f} kN")
    pdf.calc_expression("R  = V*",
                        f"= {beam_actions.R_max:.2f} kN")
    pdf.thin_rule()

    # 3.3 Bending
    pdf.sub_heading("3.3  Bending Capacity Check")
    fb = grade["fb"]
    Zx = section.Zx
    phi_Mx = phi * float(k1) * K4_DRY * K5_DEFAULT * float(k8_val) * float(k12_val) * fb * Zx
    phi_Mx_knm = phi_Mx / 1e6
    pdf.calc_line(f"phi.Mx = phi x k1 x k4 x k5 x k8 x k12 x f'b x Zx")
    pdf.calc_expression(
        f"= {phi} x {k1} x {K4_DRY} x {K5_DEFAULT} x {k8_val} x {k12_val} x {fb} x {Zx:.0f}",
        f"= {phi_Mx_knm:.2f} kNm")
    bending_util = beam_actions.M_star / phi_Mx_knm * 100 if phi_Mx_knm > 0 else 999
    bending_pass = bending_util <= 100
    pdf.calc_result_line(
        f"M* / phi.Mx = {beam_actions.M_star:.2f} / {phi_Mx_knm:.2f} = {bending_util:.0f}%  "
        f"[{'PASS' if bending_pass else 'FAIL'}]",
        passed=bending_pass)
    pdf.thin_rule()

    # 3.4 Shear
    pdf.sub_heading("3.4  Shear Capacity Check")
    fs = grade.get("fs")
    if fs is not None:
        As = section.shear_area()
        phi_Vs = phi * float(k1) * K4_DRY * K5_DEFAULT * fs * As / 1e3
        pdf.calc_line(f"phi.Vs = phi x k1 x k4 x k5 x f's x (2/3.b.d)")
        pdf.calc_expression(
            f"As = 2/3 x {section.b:.0f} x {section.d:.0f}",
            f"= {As:.0f} mm2")
        pdf.calc_expression(
            f"= {phi} x {k1} x {K4_DRY} x {K5_DEFAULT} x {fs} x {As:.0f} / 1000",
            f"= {phi_Vs:.2f} kN")
        shear_util = beam_actions.V_star / phi_Vs * 100 if phi_Vs > 0 else 999
        shear_pass = shear_util <= 100
        pdf.calc_result_line(
            f"V* / phi.Vs = {beam_actions.V_star:.2f} / {phi_Vs:.2f} = {shear_util:.0f}%  "
            f"[{'PASS' if shear_pass else 'FAIL'}]",
            passed=shear_pass)
    else:
        pdf.calc_line("Shear data not available for this grade -- check manually")
    pdf.thin_rule()

    # 3.5 Bearing
    pdf.sub_heading("3.5  Bearing Capacity Check")
    fp = grade.get("fp")
    if fp is not None:
        Ab = section.bearing_area(bearing_mm)
        phi_Np = phi * float(k1) * float(k3_val) * K4_DRY * K5_DEFAULT * fp * Ab / 1e3
        pdf.calc_line(f"phi.Np = phi x k1 x k3 x k4 x k5 x f'p x Ab")
        pdf.calc_expression(
            f"Ab = lb x b = {bearing_mm:.0f} x {section.b:.0f}",
            f"= {Ab:.0f} mm2")
        pdf.calc_expression(
            f"= {phi} x {k1} x {k3_val} x {K4_DRY} x {K5_DEFAULT} x {fp} x {Ab:.0f} / 1000",
            f"= {phi_Np:.2f} kN")
        bearing_util = beam_actions.R_max / phi_Np * 100 if phi_Np > 0 else 999
        bearing_pass = bearing_util <= 100
        pdf.calc_result_line(
            f"R / phi.Np = {beam_actions.R_max:.2f} / {phi_Np:.2f} = {bearing_util:.0f}%  "
            f"[{'PASS' if bearing_pass else 'FAIL'}]",
            passed=bearing_pass)
    else:
        pdf.calc_line("Bearing data not available for this grade -- check manually")
    pdf.thin_rule()

    # 3.6 Deflection Check (Short-term and Long-term)
    pdf.sub_heading("3.6  Deflection Check")
    from .beam_analysis import calc_deflection
    E = grade["E"]
    Ix = section.Ix
    allowable = span * 1000.0 / defl_limit

    pdf.calc_expression("E", f"= {E:.0f} MPa")
    pdf.calc_expression("Ix", f"= {Ix:.0f} mm4")
    pdf.calc_expression(
        f"Allowable = L/{defl_limit} = {span*1000:.0f}/{defl_limit}",
        f"= {allowable:.1f} mm")
    pdf.ln(1)

    # 3.6a Short-term deflection
    pdf.calc_line("Short-term: delta_st = 5.w_short.L4 / (384.E.I)")
    delta_st = calc_deflection(w_sls_short, span, E, Ix)
    pdf.calc_expression(
        f"w_short = G + 0.7Q",
        f"= {w_sls_short:.3f} kN/m")
    pdf.calc_expression(
        f"= 5 x {w_sls_short:.3f} x ({span*1000:.0f})4 / (384 x {E:.0f} x {Ix:.0f})",
        f"= {delta_st:.2f} mm")
    defl_st_util = delta_st / allowable * 100 if allowable > 0 else 999
    defl_st_pass = defl_st_util <= 100
    pdf.calc_result_line(
        f"delta_st / allow = {delta_st:.2f} / {allowable:.1f} = {defl_st_util:.0f}%  "
        f"[{'PASS' if defl_st_pass else 'FAIL'}]",
        passed=defl_st_pass)
    pdf.ln(1)

    # 3.6b Long-term deflection (with creep factor k2)
    pdf.calc_line(f"Long-term: delta_lt = k2 x 5.w_long.L4 / (384.E.I),  k2 = {k2}")
    delta_long_elastic = calc_deflection(w_sls_long, span, E, Ix)
    delta_lt = k2 * delta_long_elastic
    pdf.calc_expression(
        f"w_long = G + 0.4Q",
        f"= {w_sls_long:.3f} kN/m")
    pdf.calc_expression(
        f"delta_elastic = 5 x {w_sls_long:.3f} x ({span*1000:.0f})4 / (384 x {E:.0f} x {Ix:.0f})",
        f"= {delta_long_elastic:.2f} mm")
    pdf.calc_expression(
        f"delta_lt = k2 x delta_elastic = {k2} x {delta_long_elastic:.2f}",
        f"= {delta_lt:.2f} mm")
    defl_lt_util = delta_lt / allowable * 100 if allowable > 0 else 999
    defl_lt_pass = defl_lt_util <= 100
    pdf.calc_result_line(
        f"delta_lt / allow = {delta_lt:.2f} / {allowable:.1f} = {defl_lt_util:.0f}%  "
        f"[{'PASS' if defl_lt_pass else 'FAIL'}]",
        passed=defl_lt_pass)

    # ═══════════════════════════════════════════════════════════════
    # SECTION 4 — Results Summary
    # ═══════════════════════════════════════════════════════════════
    pdf.section_heading(4, "Results Summary")

    # Table
    pdf.set_font("Helvetica", "B", 8.5)
    col_w = [35, 28, 28, 22, 28, 22]
    headers = ["Check", "Demand", "Capacity", "Unit", "Util %", "Status"]
    pdf.set_fill_color(240, 242, 248)
    for i, h in enumerate(headers):
        pdf.cell(col_w[i], 5.5, h, border=1, align="C", fill=True)
    pdf.ln()

    pdf.set_font("Courier", "", 8.5)
    for r in results:
        status = "PASS" if r.passed else "FAIL"
        row = [
            r.name,
            f"{r.demand:.2f}",
            f"{r.capacity:.2f}",
            r.unit,
            f"{r.utilisation:.0f}%",
            status,
        ]
        for i, val in enumerate(row):
            if not r.passed and i == 5:
                pdf.set_text_color(*CLR_FAIL)
                pdf.set_font("Courier", "B", 8.5)
            elif i == 5:
                pdf.set_text_color(*CLR_PASS)
                pdf.set_font("Courier", "B", 8.5)
            pdf.cell(col_w[i], 5.5, val, border=1, align="C")
            pdf.set_text_color(*CLR_BLACK)
            pdf.set_font("Courier", "", 8.5)
        pdf.ln()
    pdf.ln(4)

    # Overall verdict box
    all_passed = all(r.passed for r in results)
    max_util = max(r.utilisation for r in results)

    pdf.set_font("Helvetica", "B", 14)
    x = pdf.get_x()
    y = pdf.get_y()
    if all_passed:
        pdf.set_fill_color(230, 248, 230)
        pdf.set_draw_color(*CLR_PASS)
        pdf.set_line_width(0.8)
        pdf.rect(x, y, 190, 12, style="DF")
        pdf.set_text_color(*CLR_PASS)
        pdf.set_xy(x, y + 1.5)
        pdf.cell(190, 9, f"DESIGN ADEQUATE -- Max utilisation {max_util:.0f}%",
                 align="C")
    else:
        pdf.set_fill_color(255, 230, 230)
        pdf.set_draw_color(*CLR_FAIL)
        pdf.set_line_width(0.8)
        pdf.rect(x, y, 190, 12, style="DF")
        pdf.set_text_color(*CLR_FAIL)
        pdf.set_xy(x, y + 1.5)
        failing = [r.name for r in results if not r.passed]
        pdf.cell(190, 9,
                 f"DESIGN INADEQUATE -- Failing: {', '.join(failing)}",
                 align="C")

    pdf.set_text_color(*CLR_BLACK)
    pdf.set_draw_color(*CLR_BLACK)
    pdf.set_line_width(0.3)

    pdf.output(filepath)

    # Clean up temp logo
    try:
        os.unlink(logo_path)
    except OSError:
        pass

    return filepath
